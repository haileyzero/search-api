# search-api
## 개발환경
* Springboot 2.7.11
* Gradle 기반 멀티모듈 프로젝트
* Java 11
* RDBS: H2
* In Memory: embedded-redis 0.7.2
* Swagger 3.0
* 외부 라이브러리 및 오픈소스
  * Spring Data Redis
    * 단순 조회용도의 간편한 데이터 액세스 및 속도개선(DB 부하분산)을 위해 사용
  * Spring Data JPA
    * 번거로운 반복작업(CRUD) 작업 최소화 및 유연성을 위해 사용
  * OpeAPI UI
    * API 문서화 및 테스트를 위해 사용
  * Spring AOP
    * 중복코드 제거(로깅) 및 횡단관심사 분리를 위해 사용
  * Spring Cache
    * 애플리케이션의 부하분산 및 효율적인 데이터 접근을 위해 사용

## 주요기능 및 내용
### 1. 공통
* 불변객체의 싱글턴 디자인 패턴으로 Thread-safe하게 구현했습니다.
* 애플리케이션의 지속적 유지보수 및 확장, 대용량 처리에 용이하도록 아래와 같이 설계했습니다.
  * 멀티모듈: 비즈니스 로직은 api 모듈 / 공통된 모델 및 repository는 core 모듈 / 요구사항대로 api를 호출하는 bff 모듈로 초기 구상하였으나 시간이 부족하여 코드 상 표현하지 못했습니다.
  * 객체지향: 코드의 재사용성과 유지보수를 위해 상속과 다형성을 고려했으며 이를 통해 의존성을 최소화했습니다. 특히 새로운 검색 API 변경에 대해 유연하도록 설계했습니다.
  * dto: 데이터 전달을 표준화하여 유지보수 및 확장성을 고려하였습니다. 특히 공통 result에 대해서는 제네릭으로 표현했습니다.
  * AOP: 요구사항인 핵심 비즈니스 로직과 부가기능(로깅, 캐싱)을 분리함으로써 중복코드 제거 및 의존성 최소화에 집중했습니다. 또한 부가기능(로깅, 캐싱)에 대해 비용 등을 계산하여 필요에 따라 활성화/비활성화할 수 있습니다. 특히 캐싱의 경우 키워드에 따른 검색결과 값을 캐싱되도록 하였습니다. 또한 장소의 경우 상대적으로 자주 갱신되지 않다고 생각했으며, 외부 API 호출 비용 및 캐시 데이터 비용 등을 고려하여 유효 기간은 5분으로 설정하였습니다. 
  * swagger-ui: API 문서화 및 테스트, 분석에 용이하여 추가했습니다.
  * Exception: 요구사항 핵심 비즈니스 로직에 대해서는 ServiceException을 통해 사용자에게 안내가 필요한 부분이 있다면 인지할 수 있도록 로깅을 통해 HttpStatus와 메세지가 보이도록 구현하였습니다. 
  * 캐싱: 대용량 트래픽에 대한 처리를 분산하고 반응성 및 가용성을 위해, 가장 중요한 장소검색 기능을 캐싱처리 하였습니다.

### 2. 장소검색
* 요구사항과 예시의 케이스를 모두 만족하는데에 집중했습니다.
* 공통적으로 확장성을 고려하여 SearchAPI를 인터페이스로 생성하여 공통화하고, 이를 각 OpenAPI 서비스가 상속받아 동작하도록 구현하는데 집중했습니다.
* 각 OpenAPI 등 발생가능한 Exception에 대해 적절한 상태 및 메세지를 확인할 수 있도록 구현했습니다. 

#### (1) 정렬 알고리즘
* 네이버의 경우 html 태그가 업체명에 포함되어 있어 제거하였습니다.
* 정렬 결과값에 대해 각 키워드에 대한 결과값을 캐싱처리를 하였습니다.
* 요구사항에서 카카오 검색 API와 네이버 검색 API가 각각 최대 5개씩이라고 하였으나, 특정 서비스 검색 결과가 5개 이하면 총 10개에 맞게 최대한 출력하라는 조건대로 구현했습니다. 

#### (2) 검색 결과 유사도 판단
* 네이버의 경우 html 태그가 업체명에 포함되어 있어 제거하였으며, 업체명의 공백을 제거하여 유사도를 비교하였습니다. 유사도는 85% 유사하면 동일 업체로 판단하였습니다.

### 3. 검색 키워드 목록
* Redis를 사용하여 반복적이고 간편한 데이터 조회에 대해 빠르게 결과 값을 받아볼 수 있도록 구현했습니다.

## 테스트
### swagger
http://localhost:8080/swagger-ui/index.html
### curl
1. 장소검색
```
curl -X 'GET' \
'http://localhost:8080/search?keyword=카카오뱅크' \
-H 'accept: application/json;charset=UTF-8'
```

2. 검색 키워드 목록
```
curl -X 'GET' \
  'http://localhost:8080/rank' \
  -H 'accept: application/json;charset=UTF-8'  
```

## 회고
1. 네이버 및 카카오 설정에 대해 별도 properties로 관리하고, 이를 가져다가 쓰도록 구현했지만 5와 10이라는 숫자는 다른 구현 우선순위에 밀려 비즈니스 로직에 static하게 표현한 것이 아쉽습니다.
2. 검색 결과에 대해 유사도 판단하는 알고리즘이 단순 장소명에 문자열 유사도 비교인 것이 아쉽습니다. 실제로 다른 장소이지만 80% 유사도를 가진 장소가 나오는 케이스도 있었기에 유사도를 85%로 하여 제출하였지만, 거리 계산하는 로직 등이 추가되었다면 더욱 완성도있었을 것 같습니다.
3. 멀티모듈 프로젝트로 구성하였고, 설계 시 각 모듈의 역할을 잘 분리(비즈니스 로직은 api 모듈 / 공통된 모델 및 repository는 core 모듈 / 요구사항대로 api를 호출하는 bff 모듈)했음에도 시간 문제로 구현하지 못한 것이 아쉽습니다. 특히 현재 프로젝트에 core 프로젝트가 이도저도 아니게 남아있게 된 채로 제출하게 되어 완성도면에서 아쉽습니다.
